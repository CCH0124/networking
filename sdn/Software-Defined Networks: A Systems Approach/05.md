### Chapter 5: Switch OS 詳細重點整理

#### 1. Switch OS 的定位與基礎

首先，我們需要建立一個清晰的心智模型：交換器作業系統 (Switch OS) 就像一台伺服器的作業系統。它通常基於一個通用處理器，運行一個以 Linux 為基礎的作業系統，並負責管理一顆專門用於封包轉送的「加速器」——也就是 NPU (Network Processing Unit)，這在概念上與伺服器中的 GPU 非常相似。

這個領域最常見的基礎是**開放網路 Linux (Open Network Linux, ONL)**，這是一個 OCP (Open Compute Project) 的開源專案。ONL 以 Debian Linux 發行版為起點，並增加了對交換器特有硬體的支援，例如 SFP (可插拔光模組) 介面。

本章節的核心重點並非深入探討底層的設備驅動程式，而是聚焦於 Switch OS 向**控制平面 (Control Plane)** 所暴露的**北向介面 (Northbound Interface, NBI)**。無論控制平面是本地運行在交換器上，還是像 ONOS 這樣的遠端 SDN 控制器，都是透過這套 NBI 來進行互動的。本章以 **Stratum** 作為實現這套 NBI 的具體範例。

#### 2. Stratum: 精簡型交換器作業系統 (Thin Switch OS)

Stratum 是一個由 Google 貢獻其生產等級程式碼並在 ONF 開源的專案。它被稱為「精簡型 (Thin)」交換器作業系統，關鍵在於「精簡」，因為它本質上是一個 **API 適配層 (API shim)**，運行在 ONL 之上。其價值完全體現在它所支援的一組現代化 API 上。


![](https://sdn.systemsapproach.org/_images/Slide17.png) High-level schematic of Stratum, a Thin Switch OS running on top of Open Networking Linux.

**Stratum 的架構與三大核心介面：**

Stratum 暴露了三個主要的北向介面，這也是本章節最重要的知識點：

1.  **P4Runtime**：用於**控制交換器的轉送行為**。
2.  **gNMI (gRPC Network Management Interface)**：用於**配置交換器**。
3.  **gNOI (gRPC Network Operations Interface)**：用於存取交換器上**其他的操作變數**。

這三個介面全部都是 **gRPC 服務**。這意味著它們的 API 方法和參數都是由 **Protocol Buffers (protobufs)** 來定義的。採用 gRPC 與 protobufs 帶來了巨大的工程優勢：Stratum 無需再像過去的協定（如 OpenFlow）那樣，耗費大量精力去處理訊息格式、可靠性、向後兼容性與安全性等難題，這些都由 gRPC 框架解決了。

**Stratum 在軟體堆疊中的位置：**

*   **上層**：透過 P4Runtime, gNMI, gNOI 與遠端控制器溝通。
*   **下層**：
    *   與晶片廠商提供的 **SDK (軟體開發套件)** 互動，以控制 NPU。這類似於傳統作業系統中的設備驅動程式。
    *   與 **ONL Platform (ONLP)** API 互動，以存取硬體計數器、監控器、狀態變數等平台相關資訊。

**Stratum 如何實現廠商無關性 (Vendor-Agnostic)：**

Stratum 的內部設計旨在屏蔽底層硬體的差異。

*   對於**可程式化晶片** (如 Tofino)，Stratum 基本上是**直接透傳 (pass-through)**。來自上層的 P4Runtime 呼叫會被直接傳遞給 Barefoot 的 SDK。
*   對於**固定功能晶片** (如 Tomahawk)，Stratum 則扮演**翻譯者**的角色。它會維護必要的運行時狀態，將 P4Runtime 的呼叫（基於一個通用的 `switch.p4` 模型）翻譯成對應的 Broadcom SDK 呼叫。例如，將一個 P4Runtime 的寫入表格操作，翻譯成 Broadcom SDK 的 `bcm_l3_route_create` 函式呼叫。

#### 3. P4Runtime: 可程式化資料平面的控制 API

P4Runtime 是控制器與交換器之間的**運行時合約 (Runtime Contract)**。這個合約並非手動撰寫，而是由 P4 工具鏈自動生成的。

**核心概念：**

*   **P4 工具鏈的雙重輸出**：P4 編譯器最關鍵的一個特點是，它不僅會生成載入到交換晶片中的**二進位檔**，還會同時生成用於在運行時控制該晶片的**介面定義**。

![](https://sdn.systemsapproach.org/_images/Slide18.png) P4 toolchain achieves ASIC-independence and auto-generates P4Runtime Contract (represented as a Protocol Buffer specification).


*   **p4info 檔案**：編譯器輸出的 `forward.p4info` 檔案扮演了關鍵角色。它使用 protobuf 格式，精確地描述了原始 P4 程式 (`forward.p4`) 中所有可被外部控制器存取的元素。例如，它會詳細定義：
    *   表格的名稱 (`ipv4_lpm`)。
    *   匹配欄位 (`hdr.ipv4.dstAddr`)、位元寬度 (`32`) 與匹配類型 (`LPM`)。
    *   可執行的動作 (`ipv4_forward`, `drop`) 及其參數 (`dstAddr`, `port`)。
*   **自動化流程**：有了 `p4info`，gRPC 工具鏈就可以自動生成客戶端與伺服器端的程式碼存根 (stubs)，讓控制器能夠以一種型別安全 (type-safe) 的方式，透過 P4Runtime API 來讀取、寫入、修改或刪除轉送表中的條目。如範例所示，一個 Python 控制器程式可以輕鬆地建構一個 `TableEntry` 物件並寫入交換器。

```python=
import p4runtime_lib.helper
	...
table_entry = p4info_helper.buildTableEntry(
    table_name="MyIngress.ipv4_lpm",
    match_fields={
        "hdr.ipv4.dstAddr": (dst_ip_addr, 32)
    },
    action_name="MyIngress.ipv4_forward",
    action_params={
        "dstAddr": next_hop_mac_addr,
        "port": outport,
    })
ingress_sw.WriteTableEntry(table_entry)
```

#### 4. gNMI 與 gNOI: 現代化的配置與操作 API

SDN 的轉型也推動了網路設備配置方式的現代化，從過去基於 SNMP/MIB 和 CLI 的模式，轉向**程式化的配置 API**。

**核心概念：**

*   **YANG**：一種現代化的建模語言，用於定義可被讀寫的資料結構。它取代了過去僅存在於標準文件中的文字描述，讓資料模型本身也成為了可被程式處理的對象。
*   **OpenConfig**：一個由網路營運商主導的行業標準化組織，致力於使用 YANG 建立一套通用的、廠商無關的配置模型。OpenConfig 的模型明確區分了可讀寫的**配置狀態 (configuration state, `rw`)** 和唯讀的**操作狀態 (operational state, `ro`)**，後者也包含了網路遙測資料。
*   **gNMI**：一個基於 gRPC 的網路管理介面，被視為未來的主流管理協定。它使用 YANG 工具鏈將 OpenConfig 模型轉換為 gRPC 服務。其核心 gRPC 服務包括 `Get` (讀取)、`Set` (寫入) 和 `Subscribe` (訂閱遙測串流)。
    *   Stratum 關注的 OpenConfig 模型主要集中在資料平面相關的配置，如介面、VLANs、QoS、LACP 等，因為像 BGP 這樣的控制協定已移至中央控制器實現。
*   **gNOI**：與 gNMI 機制相同，但處理的範疇不同。gNMI 主要處理**持久性狀態 (persistent state)** 的配置，而 gNOI 則處理**短暫狀態 (ephemeral state)** 或**非冪等操作 (non-idempotent actions)**，例如 `Reboot`、`Ping`、`Traceroute` 等。兩者常被合稱為 **gNXI**。

![](https://sdn.systemsapproach.org/_images/Slide25.png) YANG toolchain used to generate gRPC-based runtime for gNMI.


#### 5. SONiC 與 PINS: 產業的融合趨勢

*   **SONiC**：另一個在業界非常有影響力的開源、廠商無關的 Switch OS，由微軟開源並應用於 Azure 雲端。它基於 SAI (Switch Abstraction Interface) 這個廠商無關的 SDK。
*   **PINS (P4 Integrated Network Stack)**：Stratum 和 SONiC 社群正共同努力，推動一個名為 PINS 的融合方案，旨在結合兩者的優點。
    *   **目標**：其核心目標是讓採用固定功能抽象層 (SAI) 的網路，能夠以一種**漸進且低風險**的方式，享受到可程式化管線帶來的好處。
    *   **實現方式**：透過一個名為 `sai.p4` 的 P4 程式來定義 SAI 的行為模型與管線。這使得遠端 SDN 控制器可以使用 P4Runtime 和 gNMI 與 SAI 互動，同時也讓開發者能用 P4 來擴展 SAI 的功能，加速資料平面的功能創新。

**總結：**
本章節清晰地描繪了現代 SDN 交換器上的軟體層。它透過 **Stratum** 這個範例，展示了如何利用 **P4Runtime、gNMI、gNOI** 這一套基於 gRPC 和 Protobufs 的現代化 API，來實現對底層轉送硬體的**程式化控制、配置與操作**。這套架構不僅屏蔽了不同硬體廠商的差異，更重要的是，它將網路設備從一個封閉的黑盒子，轉變為一個開放、可程式化的平台。最後，透過 **PINS** 計畫，我們也看到了業界正朝著融合固定功能與可程式化管線的方向發展，而**擁抱可程式化管線及其工具鏈是實現這一切創新的基礎**。
